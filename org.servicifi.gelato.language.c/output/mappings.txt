var1: num
var9: ACCOUNTS_FILE
var8: infile
var10: stderr
var0: ????
var7: es
var11: i
var6: input


// if argument to a function has ampersand (&), then make it defines instead of uses
// i++ : if(postcrement): {uses, then defines;} else {defines; then uses);
//         es = (struct employee *)malloc(sizeof(struct employee) * num);//????
//	16.0:16.1:[uses(var0);uses(var0)];
// how to translate structure member access expressions? e.g. employee.id. is it [uses(employee)]? or is it [uses(employee), uses(id)]? should `id` be assigned a fresh variable?
// break statement is not properly translated
// var6: input; two local variables of the same name mapped to the same fresh variable
// parameter is not used to refer to a local variable



    void updateEmployeeDetails(struct employee e) {
        struct employee input;

        FILE *outfile = fopen(ACCOUNTS_FILE,"rb+");

        while(fread(&input,sizeof(input),1,outfile)==1)// fetch all records from file
        {
            if(strcmp(input.empId,e.empId)==0) {
                fseek(outfile,-sizeof(struct employee),SEEK_CUR); // move the cursor 1 step back from current position
                fwrite(&input,sizeof(struct employee),1,outfile); // override the record

                break;
            }
        }


        return;
    }

var12: outfile
// var6: input; two local variables of the same name mapped to the same fresh variable
var13:
var3:
var14: SEEK_CUR


// how to translate structure member access expressions? e.g. employee.id. is it [uses(employee)]? or is it [uses(employee), uses(id)]? should `id` be assigned a fresh variable?
// break statement is not properly translated
// var6: input; two local variables of the same name mapped to the same fresh variable


2.0:Procedure updateEmployeeDetails(val var4){
	34.0:34.1:[uses(var9);uses(var9);defines(var12)];
	35.0:if(36.0:[uses(var12)])then
		38.0:{
			40.0:40.1:[uses(var10);uses(var10)];
		};
	43.0:43.1:[uses(var12);uses(var12)];
	45.0:while(58.1:[uses(var6);uses(var6);uses(var12);uses(var12)])do 45.1:{
		46.0:if(49.1:[uses(var6);uses(var6);uses(var13);uses(var13);uses(var3);uses(var3);uses(var13);uses(var13)])then
			50.0:{
				52.0:52.1:[uses(var12);uses(var12);uses(var14);uses(var14)];
				55.0:55.1:[uses(var6);uses(var6);uses(var12);uses(var12)];
			};
	};

	61.0:61.1:[uses(var12);uses(var12)];
	63.0:return;
}
